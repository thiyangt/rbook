# Data Structures

There are five main data structures in R. They are:

1.  vectors

2.  matrix

3.  array

4.  data frame

5.  list

## Vectors

1.  One dimensional data object.

2.  Homogeneous data structure. That means data in a vector must only be one type or mode (numeric, character, or logical). You cannot mix different types of data. If you try to mix different types of data, R will automatically convert them into one type.

### Creating Vectors

Vectors can be made in four primary ways. They are

i.  using `c()` function

ii. using `:` function

iii. using `seq` function

iv. using `rep` function

Methods ii–iv simplify vector creation. They are useful when there is a pattern in data.

### Concatenate: `c()`

syntax:

Example:

The following will create the vector but not assigned a name.

```{r}
c(1996, 1998, 2000, 2005)
```

Assigning a name to vector:

The advantage of assigning a name is that we can reuse the same set of values by calling the vector name.

```{r}
a <- c(1996, 1998, 2000, 2005)
a
```

### Colon: `:`

The `:` function can be used to create a regular decreasing or increasing sequence.

Examples:

```{r}
1:10
10:1
-0.5:10
-0.3:10
```

In all of the above sequences the increment is one. The output will display the numbers only within the range.

### Sequence: `seq`

`seq` function cal also be used for creating regular sequence. With `seq` you can control the increment and length of the output.

**Example 1**

```{r}
seq(1, 19)
```

**Example 2**

```{r}
seq(1, 19, length.out=8)
```

**Example 3**

```{r}
seq(1, 19, by = 3)
```

### Repeat: `rep`

The `rep` function can be used if there is a pattern of repetition in the data.

**Example 1**

The number 8 is repeated three times.

```{r}
rep(8, 5)
```

**Example 2**

The sequence `1, 2, 3` is repeated five times.

```{r}
rep(1:3, times=5)
```

**Example 3**

Same as in Example 2 above.

```{r}
rep(1:3, 5)
```

**Example 4**

Each element in the sequence is repeated five times.

```{r}
rep(1:3, each=5)
```

**Example 5**

First, each element is repeated five times. After that, the whole sequence is repeated three times.

```{r}
rep(1:3, each=5, times=3)
```

**Example 6**

Same as before. Changing the ordering of `each` and `time` does not change the output.

```{r}
rep(1:3, times=3, each=5)
```

### Coercion

When you try to include different types they will be coerced to the most flexible type.

```{r}
a <- c(1, 3, "GPA", TRUE, 1L)
typeof(a)
```

Explicit coercion means that if we try to convert a data type to another data type intentionally using a specific function. For example,

```{r}
b <- c(3.1, 3.2, 3.7, 5.9)
b
as.integer(b)
```

### Functions that can be used to inspect vectors

Consider the vector below

```{r}
example.vec <- c(1,  2,  3, 4, 5, 6, 7, 8)
```

1.  To check the storage mode

```{r}
typeof(example.vec)
```

2.  To check the class type

```{r}
class(example.vec)
```

3.  Testing functions

```{r}
is.character(example.vec)
is.integer(example.vec)
is.logical(example.vec)
is.double(example.vec)
```

4.  Mathematical and statistical functions

```{r}
sum(example.vec)
mean(example.vec)
summary(example.vec)

```

5.  To check if there are any missing values

```{r}
is.na(example.vec)
```

There are many more functions that you can use with vectors. We will learn about them in the upcoming chapters.

### Exercise

1.  Write R codes to create the following vectors: If you see patterns in the data, use vector simplification methods.

<!-- -->

i.  

```{r, echo=FALSE}
c(1990, 1992, 1934, 1957, 1970, 2000, 2005)
```

ii. 

```{r, echo=FALSE}
rep(c(3, 6, 9), times=5)
```

iii. 

```{r, echo=FALSE}
rep(c(3, 6, 9), each=5)
```

iv. 

```{r, echo=FALSE}
rep(c(3, 6, 9), each=5, times=2)
```

v.  

```{r, echo=FALSE}
seq(1, 36, by=3)
```

vi. 

```{r, echo=FALSE}
seq(0.1, 0.3, length=100)
```

vii. 

```{r, echo=FALSE}
-0.5:10.5

```

viii. 

```{r, echo=FALSE}
seq(1, 36)*2
```

2.  Use the `typeof()` function to check the R storage mode of the following vectors and `class()` to check the class type of the vector.

```{r}
logical_vector <- c(TRUE, FALSE, TRUE, FALSE)
integer_vector <- c(1L, 2L, 3L, 4L)
double_vector <- c(1.1, 2.2, 3.3, 4.4)
complex_vector <- c(1+1i, 2+2i, 3+3i, 4+4i)
character_vector <- c("a", "b", "c", "d")
null_vector <- NULL
time_data <- 1996:2006
time_series_data <- ts(1996:2006)
```

3.  Create the vector (3, 3, 3, . . . 3, 6, 6, . . . 6, 9, 9, 9, . . . 9), where there are 10 occurrences of 3, 20 occurrences of 6 and 30 occurrences of 9.

4.  Find the value of the following expression.

<!-- -->

i.  $\sum_{i=1}^{100}i$

ii. $\sum_{i=1}^{100}i^2$

<!-- -->

5.  Generate a sequence using the code seq(from=1, to=10, by=1). What other ways can you generate the same sequence?

6.  Create a vector to hold population values, and label each element with the corresponding province name. The plot will display population values when hovered over.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(ceylon)
library(ggplot2)
library(viridis)
library(plotly)
library(sf)
p1 <- ggplot(province) + 
  geom_sf(mapping = aes(fill = population), show.legend = TRUE) +
  scale_fill_viridis() 
 
ggplotly(p1)
```

### Vector Operations

Vector operations are performed element by element. 

```{r}
a <- 1:10
b <- rep(10:100, by=10)
a + b
a/b
a*b
a-b
```

```{r, comment=NA}
c(10, 100, 100) + 2 # two is added to every element in the vector
```

Example for operations between two vectors

```{r, comment=NA}
v1 <- c(1, 2, 3); v2 <- c(10, 100, 1000)
v1 + v2
```


**Add two vectors of unequal length**

The short vector repeats until it matches the length of the long vector.

```{r, comment=NA}
longvec <- seq(10, 100, length=10); shortvec <- c(1, 2, 3, 4, 5)

shortvec + longvec

```

## Matrix

Matrix is a 2-dimentional and a homogeneous data structure

**Syntax to create a matrix**

``` r
matrix_name <- matrix(vector_of_elements, 
                      nrow=number_of_rows,
                      ncol=number_of_columns,
                      byrow=logical_value, # If byrow=TRUE, then the matrix is filled in by row.
                      dimnames=list(rnames, cnames)) # To assign row names and columns
```

**Example**

```{r, comment=NA}
matrix(1:6, nrow=2, ncol=3)
matrix(1:6, nrow=2)
matrix(1:6, ncol=3)

```

### Matrix fill by rows/ columns

```{r, comment=NA}
values <- c(10, 20, 30, 40)
matrix1 <- matrix(values, nrow=2) # Matrix filled by columns (default option)
matrix1
matrix2 <- matrix(values, nrow=2, byrow=TRUE) # Matrix filled by rows
matrix2
```

-   byrow=TRUE: matrix is filled in by row

-   byrow=FALSE: matrix is filled in by column

-   Default is by column

### Naming matrix rows and columns

```{r, comment=NA}
rnames <- c("R1", "R2")
cnames <- c("C1", "C2")
matrix_with_names <- matrix(values, nrow=2, dimnames=list(rnames, cnames))
matrix_with_names
```

### Matrix subscript

`matraix_name[i, ]` gives the ith row of a matrix

```{r, comment=NA}
matrix1[1, ]
```

`matraix_name[, j]` gives the jth column of a matrix

```{r, comment=NA}
matrix1[, 2]
```

`matraix_name[i, j]` gives the ith row and jth column element

```{r, comment=NA}
matrix1[1, 2]
```

```{r, comment=NA}
matrix1[1, c(1, 2)] 
```

### `cbind` and `rbind`

Matrices can be created by column-binding and row-binding with `cbind()` and `rbind()`

```{r, comment=NA}
x <- 1:3
y <- c(10, 100, 1000)
cbind(x, y) # binds matrices horizontally
rbind(x, y) #binds matrices vertically
```

### Matrix operations

Transpose

```{r, comment=NA}
t(x)
```

Matrix multiplication

```{r, comment=NA}
y <- matrix(seq(10, 60, by=10), nrow=3)
z <- x %*% y
z
```

Find x in: m\*x=n

``` r
solve(m, n)
```

### Exercise

i.  Write R codes to obtain following matrix outputs

<!-- -->

a.  

```{r, echo=FALSE}
matrix(seq(10, 100, by=10), ncol=5)
```

b.  

```{r, echo=FALSE}
matrix(seq(10, 100, by=10), ncol=5, byrow = TRUE)
```

c.  

```{r, echo=FALSE}
matrix(1:20, ncol=4, dimnames = list(c("Row1", "Row2", "Row3", "Row4", "Row5"), c("C1", "C2", "C3", "C4")))
```

2.  Mr. Perera who lives in Soratha Mawatha - Wijerama wants to sell his house. He wants to decide a price for his house to list it in the market. He believes that the size of the house is one likely determinant of price. He asked from 10 homes in the neighbourhood, "what price should you ask for your home? " and the house size (in square feet). The collected data are shown below:

```{r, comment=NA, echo=FALSE}
size_x <- seq(1000, 5500, 500)
price_y <- c(810, 1210, 1450, 1610, 1690, 2010, 1490, 1690, 1890, 2410)
data.frame(size_x, price_y)
```

(a) Write an R code to input `size_x` and `price_y` into two separate vectors.

(b) Mr. Perera wants to compute the least squares estimates of the model $\hat{Y} = \hat{\beta_0} + \hat{\beta_1}X$. Write an R code to compute $\hat{\beta_0}$ and $\hat{\beta_1}$ using the matrix operation $\hat{\beta} = (X^TX)^{-1}X^TY$. Do not use the built-in function `lm`.

Where,

$\hat{\beta} =\begin{pmatrix}
\hat{\beta_0} \\
\hat{\beta_1} \\
\end{pmatrix}$, $Y =
\begin{pmatrix}
y_1 \\
y_2 \\
y_3 \\
. \\
. \\
. \\
y_n
\end{pmatrix}$ and $X =
\begin{pmatrix}
1 & x_1 \\
1 & x_2 \\
1 & x_3 \\
. \\
. \\
. \\
1 & x_n
\end{pmatrix}$

## 3. Array

-   data structures for storing **higher** dimensional data.

-   a **homogeneous** data structure.

-   a special case of the array is the matrix.

``` r
array(vector, dimensions, dimnames) #dimnames-as a list
```

```{r, comment=NA}
a <-  array(c(10, 20, 30, 40, 50, 60), c(1, 2, 3))
a
```

### Subsetting arrays

```{r, comment=NA}
a
```

```{r, comment=NA}
a[, , 1] # Extract first entry
```

```{r, comment=NA}
a[1, ,] # All rows in each entry
```

### Exercise

1.  Create the following matrix using the `array` function

```{r, comment=NA}

matrix(1:20, ncol=5)
```

### Array with dimnames

```{r, comment=NA}
dim1 <- c("A1", "A2"); dim2 <- c("B1", "B2", "B3"); dim3 <- c("c1", "c2", "c3", "c4")
z <- array(1:24, c(2, 3, 4), dimnames = list(dim1, dim2, dim3))
z
```

### Exercise

Create a 3D array with 3 columns, 5 rows, and 2 layers in R, and enter the following values into it:

```{r, echo=FALSE}
1:30
```

## 4. Data Frames

-   Rectangular arrangement of data with rows corresponding to observational units and columns corresponding to variables.

-   More general than a matrix in that different columns can contain different modes of data.

-   It’s similar to the datasets you’d typically see in SPSS and MINITAB.

-   Data frames are the most common data structure you’ll deal with in R.

### Create a dataframe

**Syntax**

``` r
name_of_the_dataframe <- data.frame(
                          var1_name=vector of values of the first variable,
                          var2_names=vector of values of the second variable)
```

**Example**

```{r, comment=NA}
corona <- data.frame(ID=c("C001", "C002", "C003", "C004"),
                     Location=c("Beijing", "Wuhan", "Shanghai", "Beijing"),
                     Test_Results=c(FALSE, TRUE, FALSE, FALSE))
corona
```

To check if it is a dataframe

```{r, comment=NA}
is.data.frame(corona)

```

### Exercise

Write a code to store the following values in a dataframe.

```{r, echo=FALSE}
trees |> head(10) |> knitr::kable()
```

### Some useful functions with dataframes

```{r, comment=NA}
colnames(corona)
```

```{r, comment=NA}
length(corona)
dim(corona)
nrow(corona)
ncol(corona)
summary(corona)
str(corona)
```

### Convert a matrix to a dataframe

```{r, comment=NA}
mat <- matrix(1:16, ncol=4)
mat
mat_df <- as.data.frame(mat)
mat_df
```

### Subsetting data frames

**Select rows**

```{r, comment=NA}
head(mat_df) # default it shows 5 rows

head(mat_df, 3) # To extract only the first three rows 
```

```{r, comment=NA}
tail(mat_df)
```

```{r, comment=NA}
mat_df
```

**To select some specific rows**

```{r, comment=NA}
mat_df[4, ]
index <- c(1, 3)
mat_df[index, ]

```

**Select columns**

1.  Select column(s) by variable names

```{r, comment=NA}
mat_df$V1 # Method 1

mat_df[, "V1"] # Method 2
```

2.  Select column(s) by index

```{r, comment=NA}
mat_df[, 2]
```

### Built-in dataframes

there are several built-in data frames (datasets) that you can use directly without needing to import external files.

```{r}
data(iris)
```

R comes with many datasets preloaded, mostly from the datasets package. You can see them by running:

```{r}
data()
```

### Exercise

**Question 1**

Use the R dataset “iris” to answer the following questions:

1.  How many rows and columns does iris have?

2.  Select the first 4 rows.

3.  Select the last 6 rows.

4.  Select rows 10 to 20, with all columns in the iris dataset.

5.  Select rows 10 to 20 with only the Species, Petal.Width and Petal.Length.

6.  Create a single vector (a new object) called ‘width’ that is the Sepal.Width column of iris.

7.  What are the column names and data types of the different columns in iris?

8.  How many rows in the iris dataset have `Petal.Length` larger than 5 and `Sepal.Width` smaller than 3?

**Question 2**

This exercise is based on `mtcars` built-in-dataset in R. Write R codes to obtain the answers for the followings.

1.  To obtain the help file of `mtcars`

```{r, echo=FALSE, eval=FALSE}
# Using the help function
help(mtcars)

# Using the ? operator
?mtcars
```

2.  How many cars are in the mtcars dataset?

```{r, echo=FALSE, eval=FALSE}
nrow(mtcars)
```

3.  How many variables are in the mtcars dataset?

```{r, echo=FALSE, eval=FALSE}
ncol(mtcars)
```

4.  What are the column names of the mtcars dataset?

```{r, echo=FALSE, eval=FALSE}
colnames(mtcars)
```

5.  What is the mean miles per gallon (mpg) of the cars in the dataset?

```{r, echo=FALSE, eval=FALSE}
mean(mtcars$mpg)
```

6.  Which car has the highest horsepower (hp)?

```{r, echo=FALSE, eval=FALSE}
mtcars[which.max(mtcars$hp), ]
```

7.  What is the mean weight (wt) of the cars in the dataset?

```{r, echo=FALSE, eval=FALSE}
mean(mtcars$wt)
```

8.  How many cars have 8 cylinders (cyl)?

```{r, echo=FALSE, eval=FALSE}
sum(mtcars$cyl == 8)
```

9.  What is the range of displacement (disp) values in the dataset?

```{r, echo=FALSE, eval=FALSE}
range(mtcars$disp)
```

10. What is the median quarter mile time (qsec) for the cars?

```{r, echo=FALSE, eval=FALSE}
median(mtcars$qsec)
```

11. How many cars have a manual transmission (am = 1)?

```{r, echo=FALSE, eval=FALSE}
sum(mtcars$am == 1)
```

12. What is the maximum miles per gallon (mpg) in the dataset?

```{r, echo=FALSE, eval=FALSE}
max(mtcars$mpg)
```

13. What is the minimum horsepower (hp) recorded in the dataset?

```{r, echo=FALSE, eval=FALSE}
min(mtcars$hp)
```

14. Which car has the lowest weight (wt)?

```{r, echo=FALSE, eval=FALSE}
mtcars[which.min(mtcars$wt), ]
```

15. How many cars have 4 gears (gear)?

```{r, echo=FALSE, eval=FALSE}
sum(mtcars$gear == 4)
```

16. What is the standard deviation of the mpg variable?

```{r, echo=FALSE, eval=FALSE}
sd(mtcars$mpg)
```

17. What is the total number of carburetors (carb) for all cars combined?

```{r, echo=FALSE, eval=FALSE}
sum(mtcars$carb)
```

18. How many cars have a quarter mile time (qsec) less than 18 seconds?

```{r, echo=FALSE, eval=FALSE}
sum(mtcars$qsec < 18)
```

19. What is the mean value of the gear variable for cars with 6 cylinders (cyl)?

```{r, echo=FALSE, eval=FALSE}
mean(mtcars$gear[mtcars$cyl == 6])
```

20. How many cars have more than 100 horsepower (hp)?

```{r, echo=FALSE, eval=FALSE}
sum(mtcars$hp > 100)
```

21. What is the correlation between horsepower (hp) and miles per gallon (mpg)?

```{r, echo=FALSE, eval=FALSE}
cor(mtcars$hp, mtcars$mpg)
```

## 5. List

-   Lists are heterogeneous

**Syntax**

``` r
list_name <- list(entry1, entry2, entry3, ...)
```

**Example**

```{r, comment=NA}
first_list <-list(1:3, matrix(1:6, nrow=2), iris)
first_list
```

### Structure of a list

```{r, comment=NA}
str(first_list)
```

### Extract elements from a list

```{r, comment=NA}
first_list[[1]]
first_list[[3]]$Species
```

### Name entries in a list

```{r, comment=NA}
first_list_with_names <-list(a=1:3, b=matrix(1:6, nrow=2), c=iris)
first_list_with_names
```

### Extract elements using names

```{r, comment=NA}
str(first_list_with_names)
```

```{r, comment=NA}
first_list_with_names$a
first_list_with_names$c$Species
```

### Exercise

```{r, comment=NA}
c("Jan","Feb","Mar")
matrix(c(3,9,5,1,-2,8), nrow = 2)
list("green",12.3)
```

1.  Create a list containing the above vector, matrix and the list.

2.  Name the elements as `first`, `second` and `third`.
